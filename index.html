<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Ontology Viewer</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { padding: 10px; background: #f4f4f4; }
    #cy { width: 100vw; height: 90vh; border-top: 1px solid #ccc; }
    input, button { font-size: 16px; padding: 4px 8px; margin-right: 5px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="text" id="nodeSearch" placeholder="Enter node ID">
    <button onclick="focusOnNode(document.getElementById('nodeSearch').value)">Focus</button>
    <button onclick="resetView()">Reset View</button>
  </div>
  <div id="cy"></div>

  <script>
    fetch('graph.json')
      .then(res => res.json())
      .then(graphData => {
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [...graphData.nodes, ...graphData.edges],
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'background-color': ele => {
                  const type = ele.data('type');
                  const colors = {
                    Individual: '#1f77b4',
                    Campaign: '#d62728',
                    Group: '#9467bd',
                    Institution: '#2ca02c',
                    Policy: '#ff7f0e',
                    Event: '#8c564b',
                    Media: '#17becf',
                    Place: '#7f7f7f'
                  };
                  return colors[type] || '#ccc';
                },
                'text-valign': 'center',
                'text-halign': 'center',
                'color': '#fff',
                'text-outline-width': 1,
                'text-outline-color': '#000',
                'width': 40,
                'height': 40
              }
            },
            {
              selector: 'edge',
              style: {
                'label': 'data(label)',
                'curve-style': 'bezier',
                'target-arrow-shape': 'triangle',
                'line-color': '#aaa',
                'target-arrow-color': '#aaa',
                'font-size': 10,
                'text-rotation': 'autorotate',
                'text-margin-y': -8
              }
            },
            {
              selector: '.faded',
              style: {
                'opacity': 0.1,
                'text-opacity': 0.05
              }
            }
          ],
          layout: { name: 'preset' },
          minZoom: 0.2,
          maxZoom: 3
        });

        cy.on('tap', 'node', function(evt) {
          const node = evt.target;
          highlightNode(node);
        });

        window.focusOnNode = function(id) {
          const node = cy.getElementById(id);
          if (node && node.length > 0) {
            highlightNode(node);
          } else {
            alert('Node not found');
          }
        }

        window.resetView = function() {
          cy.elements().removeClass('faded');
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        function highlightNode(node) {
          cy.elements().removeClass('faded');
          cy.elements().addClass('faded');

          const center = { x: 0, y: 0 };
          node.position(center);
          node.removeClass('faded');

          const nodeId = node.id();
          const directNeighbors = new Set();
          const secondDegree = new Set();

          cy.edges().forEach(edge => {
            const src = edge.source().id();
            const tgt = edge.target().id();
            if (src === nodeId) directNeighbors.add(tgt);
            if (tgt === nodeId) directNeighbors.add(src);
          });

          cy.nodes().forEach(n => {
            const nid = n.id();
            if (nid === nodeId || directNeighbors.has(nid)) return;
            for (const dn of directNeighbors) {
              if (cy.getElementById(dn).edgesWith(n).length > 0) {
                secondDegree.add(nid);
                break;
              }
            }
          });

          cy.edges().forEach(edge => {
            const source = edge.source().id();
            const target = edge.target().id();

            if (directNeighbors.has(source) && source !== nodeId && !directNeighbors.has(target) && target !== nodeId) {
              secondDegree.add(target);
            }
            if (directNeighbors.has(target) && target !== nodeId && !directNeighbors.has(source) && source !== nodeId) {
              secondDegree.add(source);
            }
          });

          const ring1 = cy.collection();
          const ring2 = cy.collection();
          const ring3 = cy.collection();

          cy.nodes().forEach(n => {
            if (n.id() === nodeId) return;
            if (directNeighbors.has(n.id())) {
              ring1.merge(n);
            } else if (secondDegree.has(n.id())) {
              ring2.merge(n);
            } else {
              ring3.merge(n);
            }
          });

          ring1.removeClass('faded');
          ring2.removeClass('faded');
          ring3.removeClass('faded');
          node.connectedEdges().removeClass('faded');

          const radius1 = 200;
          const radius2 = 400;
          const radius3 = 600;

          const angleStep1 = (2 * Math.PI) / Math.max(ring1.length, 1);
          ring1.forEach((ele, i) => {
            const angle = i * angleStep1;
            ele.position({
              x: center.x + radius1 * Math.cos(angle),
              y: center.y + radius1 * Math.sin(angle)
            });
          });

          const angleStep2 = (2 * Math.PI) / Math.max(ring2.length, 1);
          ring2.forEach((ele, i) => {
            const angle = i * angleStep2;
            ele.position({
              x: center.x + radius2 * Math.cos(angle),
              y: center.y + radius2 * Math.sin(angle)
            });
          });

          const angleStep3 = (2 * Math.PI) / Math.max(ring3.length, 1);
          ring3.forEach((ele, i) => {
            const angle = i * angleStep3;
            ele.position({
              x: center.x + radius3 * Math.cos(angle),
              y: center.y + radius3 * Math.sin(angle)
            });
          });

          cy.layout({ name: 'preset' }).run();
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        cy.ready(() => {
          const defaultNode = cy.getElementById('individual_0');
          if (defaultNode && defaultNode.length > 0) {
            highlightNode(defaultNode);
          }
        });
      });
  </script>
</body>
</html>
