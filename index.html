<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Ontology Viewer</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { padding: 10px; background: #f4f4f4; }
    #cy { width: 100vw; height: 90vh; border-top: 1px solid #ccc; }
    input, button { font-size: 16px; padding: 4px 8px; margin-right: 5px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="text" id="nodeSearch" placeholder="Enter node ID">
    <button onclick="focusOnNode(document.getElementById('nodeSearch').value)">Focus</button>
    <button onclick="resetView()">Reset View</button>
  </div>
  <div id="cy"></div>

  <script>
    fetch('graph.json')
      .then(res => res.json())
      .then(graphData => {
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [...graphData.nodes, ...graphData.edges],
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'background-color': ele => {
                  const type = ele.data('type');
                  const colors = {
                    Individual: '#1f77b4',
                    Campaign: '#d62728',
                    Group: '#9467bd',
                    Institution: '#2ca02c',
                    Policy: '#ff7f0e',
                    Event: '#8c564b',
                    Media: '#17becf',
                    Place: '#7f7f7f'
                  };
                  return colors[type] || '#ccc';
                },
                'text-valign': 'center',
                'text-halign': 'center',
                'color': '#fff',
                'text-outline-width': 1,
                'text-outline-color': '#000',
                'width': 40,
                'height': 40
              }
            },
            {
              selector: 'edge',
              style: {
                'label': 'data(label)',
                'curve-style': 'bezier',
                'target-arrow-shape': 'triangle',
                'line-color': '#aaa',
                'target-arrow-color': '#aaa',
                'font-size': 10,
                'text-rotation': 'autorotate',
                'text-margin-y': -8
              }
            },
            {
              selector: '.faded',
              style: {
                'opacity': 0.1,
                'text-opacity': 0.05
              }
            }
          ],
          layout: { name: 'preset' },
          minZoom: 0.2,
          maxZoom: 3
        });

        cy.on('tap', 'node', function(evt) {
          const node = evt.target;
          focusOnNode(node.id());
        });

        window.focusOnNode = function(id) {
          const node = cy.getElementById(id);
          if (node && node.length > 0) {
            highlightNode(node);
          } else {
            alert('Node not found');
          }
        }

        window.resetView = function() {
          cy.elements().removeClass('faded');
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        function highlightNode(node) {
          cy.elements().removeClass('faded');
          cy.elements().addClass('faded');

          const center = { x: 0, y: 0 };
          node.position(center);
          node.removeClass('faded');

          const nodeId = node.id();
          const directNeighbors = new Set();
          const secondDegree = new Set();

          cy.edges().forEach(edge => {
            const src = edge.source().id();
            const tgt = edge.target().id();
            if (src === nodeId) directNeighbors.add(tgt);
            if (tgt === nodeId) directNeighbors.add(src);
          });

          cy.nodes().forEach(n => {
            const nid = n.id();
            if (nid === nodeId || directNeighbors.has(nid)) return;
            for (const dn of directNeighbors) {
              if (cy.getElementById(dn).edgesWith(n).length > 0) {
                secondDegree.add(nid);
                break;
              }
            }
          });

          const ring1 = cy.collection();
          const ring2 = cy.collection();
          const ring3 = cy.collection();

          cy.nodes().forEach(n => {
            if (n.id() === nodeId) return;
            if (directNeighbors.has(n.id())) {
              ring1.merge(n);
            } else if (secondDegree.has(n.id())) {
              ring2.merge(n);
            } else {
              ring3.merge(n);
            }
          });

          ring1.removeClass('faded');
          ring2.removeClass('faded');
          ring3.forEach(node => {
            const connectedToRing2 = node.connectedEdges().some(edge =>
              (ring2.has(edge.source()) && ring3.has(edge.target())) ||
              (ring3.has(edge.source()) && ring2.has(edge.target()))
            );
            if (connectedToRing2) {
              node.removeClass('faded');
            } else {
              node.addClass('faded');
            }
          });

          node.connectedEdges().removeClass('faded');
          cy.edges().forEach(edge => {
            const src = edge.source();
            const tgt = edge.target();
            if ((ring1.has(src) && ring2.has(tgt)) || (ring2.has(src) && ring1.has(tgt)) ||
                (ring2.has(src) && ring3.has(tgt)) || (ring3.has(src) && ring2.has(tgt))) {
              edge.removeClass('faded');
            }
          });

          const radius1 = 200;
          const radius2 = 400;
          const radius3 = 600;

          const angleStep1 = (2 * Math.PI) / Math.max(ring1.length, 1);
          ring1.forEach((ele, i) => {
            const angle = i * angleStep1;
            ele.position({
              x: center.x + radius1 * Math.cos(angle),
              y: center.y + radius1 * Math.sin(angle)
            });
          });

          const ring2Array = ring2.toArray();
          const ring1Ids = new Set(ring1.map(n => n.id()));

          const ring2Grouped = ring2Array.map(node => {
            const connections = cy.edges().filter(e =>
              (ring1Ids.has(e.source().id()) && e.target().id() === node.id()) ||
              (ring1Ids.has(e.target().id()) && e.source().id() === node.id())
            ).map(e => ring1Ids.has(e.source().id()) ? e.source().id() : e.target().id());

            const key = connections.sort().join(',');
            return { node, key, primary: connections[0] || '' };
          });

          ring2Grouped.sort((a, b) => {
            if (a.primary < b.primary) return -1;
            if (a.primary > b.primary) return 1;
            return a.key.localeCompare(b.key);
          });

          const ring2GroupsByPrimary = {};
          ring2Grouped.forEach(item => {
            const key = item.primary;
            if (!ring2GroupsByPrimary[key]) ring2GroupsByPrimary[key] = [];
            ring2GroupsByPrimary[key].push(item.node);
          });

          Object.entries(ring2GroupsByPrimary).forEach(([primaryId, nodes]) => {
            const primary = cy.getElementById(primaryId);
            const pos = primary.position();
            if (!pos || isNaN(pos.x) || isNaN(pos.y)) return;
            const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
            const offset = (Math.PI / 180) * 10;

            nodes.forEach((node, i) => {
              const theta = angle + offset * (i - (nodes.length - 1) / 2);
              node.position({
                x: center.x + radius2 * Math.cos(theta),
                y: center.y + radius2 * Math.sin(theta)
              });
            });
          });

          const ring3Array = ring3.filter(node => node.visible()).toArray();
          const ring2Ids = new Set(ring2.map(n => n.id()));

          const ring3Grouped = ring3Array.map(node => {
            const connections = cy.edges().filter(e =>
              (ring2Ids.has(e.source().id()) && e.target().id() === node.id()) ||
              (ring2Ids.has(e.target().id()) && e.source().id() === node.id())
            ).map(e => ring2Ids.has(e.source().id()) ? e.source().id() : e.target().id());

            const key = connections.sort().join(',');
            return { node, key, primary: connections[0] || '' };
          });

          ring3Grouped.sort((a, b) => {
            if (a.primary < b.primary) return -1;
            if (a.primary > b.primary) return 1;
            return a.key.localeCompare(b.key);
          });

          const ring3GroupsByPrimary = {};
          ring3Grouped.forEach(item => {
            const key = item.primary;
            if (!ring3GroupsByPrimary[key]) ring3GroupsByPrimary[key] = [];
            ring3GroupsByPrimary[key].push(item.node);
          });

          Object.entries(ring3GroupsByPrimary).forEach(([primaryId, nodes]) => {
            const primary = cy.getElementById(primaryId);
            const pos = primary.position();
            if (!pos || isNaN(pos.x) || isNaN(pos.y)) return;
            const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
            const offset = (Math.PI / 180) * 6;

            nodes.forEach((node, i) => {
              const theta = angle + offset * (i - (nodes.length - 1) / 2);
              node.position({
                x: center.x + radius3 * Math.cos(theta),
                y: center.y + radius3 * Math.sin(theta)
              });
            });
          });

          cy.layout({ name: 'preset' }).run();
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        cy.ready(() => {
          const defaultNode = cy.getElementById('individual_0');
          if (defaultNode && defaultNode.length > 0) {
            highlightNode(defaultNode);
          }
        });
      });
  </script>
</body>
</html>
