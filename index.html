<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Ontology Viewer</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { padding: 10px; background: #f4f4f4; }
    #cy { width: 100vw; height: 90vh; border-top: 1px solid #ccc; }
    input, button { font-size: 16px; padding: 4px 8px; margin-right: 5px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="text" id="nodeSearch" placeholder="Enter node ID">
    <button onclick="focusOnNode(document.getElementById('nodeSearch').value)">Focus</button>
    <button onclick="resetView()">Reset View</button>
  </div>
  <div id="cy"></div>  <script>
    fetch('graph.json')
      .then(res => res.json())
      .then(graphData => {
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [...graphData.nodes, ...graphData.edges],
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'background-color': ele => {
                  const type = ele.data('type');
                  const colors = {
                    Individual: '#1f77b4',
                    Campaign: '#d62728',
                    Group: '#9467bd',
                    Institution: '#2ca02c',
                    Policy: '#ff7f0e',
                    Event: '#8c564b',
                    Media: '#17becf',
                    Place: '#7f7f7f'
                  };
                  return colors[type] || '#ccc';
                },
                'text-valign': 'center',
                'text-halign': 'center',
                'color': '#fff',
                'text-outline-width': 1,
                'text-outline-color': '#000',
                'width': 40,
                'height': 40
              }
            },
            {
              selector: 'edge',
              style: {
                'label': 'data(label)',
                'curve-style': 'bezier',
                'target-arrow-shape': 'triangle',
                'line-color': '#aaa',
                'target-arrow-color': '#aaa',
                'font-size': 10,
                'text-rotation': 'autorotate',
                'text-margin-y': -8
              }
            },
            {
              selector: '.faded',
              style: {
                'opacity': 0.1,
                'text-opacity': 0.05
              }
            },
            {
              selector: '.hidden',
              style: {
                'display': 'none'
              }
            },
            {
              selector: '.faded-third',
              style: {
                'opacity': 0.2,
                'text-opacity': 0.1
              }
            }
          ],
          layout: { name: 'preset' },
          minZoom: 0.2,
          maxZoom: 3
        });

        cy.on('tap', 'node', function(evt) {
          const node = evt.target;
          highlightNode(node);
        });

        window.focusOnNode = function(id) {
          const node = cy.getElementById(id);
          if (node && node.length > 0) {
            highlightNode(node);
          } else {
            alert('Node not found');
          }
        }

        window.resetView = function() {
          cy.elements().removeClass('faded hidden faded-third');
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        function highlightNode(node) {
          cy.elements().removeClass('faded hidden faded-third');
          cy.elements().addClass('faded');

          const center = { x: 0, y: 0 };
          node.position(center);
          node.removeClass('faded');

          const nodeId = node.id();
          const directNeighbors = new Set();
          const secondDegree = new Set();

          cy.edges().forEach(edge => {
            const src = edge.source().id();
            const tgt = edge.target().id();
            if (src === nodeId) directNeighbors.add(tgt);
            if (tgt === nodeId) directNeighbors.add(src);
          });

          cy.nodes().forEach(n => {
            const nid = n.id();
            if (nid === nodeId || directNeighbors.has(nid)) return;
            for (const dn of directNeighbors) {
              if (cy.getElementById(dn).edgesWith(n).length > 0) {
                secondDegree.add(nid);
                break;
              }
            }
          });

          const ring1 = cy.collection();
          const ring2 = cy.collection();
          const ring3 = cy.collection();

          cy.nodes().forEach(n => {
            if (n.id() === nodeId) return;
            if (directNeighbors.has(n.id())) {
              ring1.merge(n);
            } else if (secondDegree.has(n.id())) {
              ring2.merge(n);
            } else {
              ring3.merge(n);
            }
          });

          ring1.removeClass('faded');
          ring2.removeClass('faded');

          const visibleRing3 = ring3.filter(n => {
            const connectedToRing2 = n.connectedEdges().some(edge =>
              (ring2.has(edge.source()) && ring3.has(edge.target())) ||
              (ring3.has(edge.source()) && ring2.has(edge.target()))
            );
            if (connectedToRing2) {
              n.removeClass('faded');
              return true;
            } else {
              n.removeClass('faded').addClass('hidden');
              return false;
            }
          });

          cy.edges().addClass('hidden');

          cy.edges().forEach(edge => {
            const src = edge.source();
            const tgt = edge.target();

            const srcId = src.id();
            const tgtId = tgt.id();
            const isInRing3 = ring3.has(src) && ring3.has(tgt);

            const isSecondToThird = (ring2.has(src) && visibleRing3.has(tgt)) ||
                                     (visibleRing3.has(src) && ring2.has(tgt));

            if (!isInRing3 &&
                (srcId === nodeId || ring1.has(src) || ring2.has(src) || visibleRing3.has(src)) &&
                (tgtId === nodeId || ring1.has(tgt) || ring2.has(tgt) || visibleRing3.has(tgt))) {

              edge.removeClass('hidden faded faded-third');
              if (isSecondToThird) edge.addClass('faded-third');
            }
          });

          const radius1 = 200;
          const radius2 = 400;
          const radius3 = 600;

          const angleStep1 = (2 * Math.PI) / Math.max(ring1.length, 1);
          ring1.forEach((ele, i) => {
            const angle = i * angleStep1;
            ele.position({
              x: center.x + radius1 * Math.cos(angle),
              y: center.y + radius1 * Math.sin(angle)
            });
          });

          const ring2Array = ring2.toArray();
          const ring1Ids = new Set(ring1.map(n => n.id()));

          const ring2Grouped = ring2Array.map(node => {
            const connections = cy.edges().filter(e =>
              (ring1Ids.has(e.source().id()) && e.target().id() === node.id()) ||
              (ring1Ids.has(e.target().id()) && e.source().id() === node.id())
            ).map(e => ring1Ids.has(e.source().id()) ? e.source().id() : e.target().id());

            const key = connections.sort().join(',');
            return { node, key, primary: connections[0] || '' };
          });

          ring2Grouped.sort((a, b) => {
            if (a.primary < b.primary) return -1;
            if (a.primary > b.primary) return 1;
            return a.key.localeCompare(b.key);
          });

          const ring2Sorted = ring2Grouped.map(item => item.node);

          const ring2GroupsByPrimary = {};
          ring2Grouped.forEach(item => {
            const key = item.primary;
            if (!ring2GroupsByPrimary[key]) ring2GroupsByPrimary[key] = [];
            ring2GroupsByPrimary[key].push(item.node);
          });

          Object.entries(ring2GroupsByPrimary).forEach(([primaryId, nodes]) => {
            const primary = cy.getElementById(primaryId);
            if (!primary || !primary.position) return;
            const px = primary.position().x;
            const py = primary.position().y;
            const angle = Math.atan2(py - center.y, px - center.x);
            const offset = (Math.PI / 180) * 10;

            nodes.forEach((node, i) => {
              const theta = angle + offset * (i - (nodes.length - 1) / 2);
              node.position({
                x: center.x + radius2 * Math.cos(theta),
                y: center.y + radius2 * Math.sin(theta)
              });
            });
          });

          const ring2Ids = new Set(ring2.map(n => n.id()));
          const ring3GroupsByPrimary = {};

          visibleRing3.forEach(node => {
            const connections = node.connectedEdges().filter(edge => ring2Ids.has(edge.source().id()) || ring2Ids.has(edge.target().id()));
            if (connections.length === 0) return;

            const connectedRing2Id = ring2Ids.has(connections[0].source().id()) ? connections[0].source().id() : connections[0].target().id();
            if (!ring3GroupsByPrimary[connectedRing2Id]) ring3GroupsByPrimary[connectedRing2Id] = [];
            ring3GroupsByPrimary[connectedRing2Id].push(node);
          });

          Object.entries(ring3GroupsByPrimary).forEach(([primaryId, nodes]) => {
            const primary = cy.getElementById(primaryId);
            if (!primary || !primary.position) return;
            const px = primary.position().x;
            const py = primary.position().y;
            const angle = Math.atan2(py - center.y, px - center.x);
            const offset = (Math.PI / 180) * 8;

            nodes.forEach((node, i) => {
              const theta = angle + offset * (i - (nodes.length - 1) / 2);
              node.position({
                x: center.x + radius3 * Math.cos(theta),
                y: center.y + radius3 * Math.sin(theta)
              });
            });
          });

          cy.layout({ name: 'preset' }).run();
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        cy.ready(() => {
          const defaultNode = cy.getElementById('individual_0');
          if (defaultNode && defaultNode.length > 0) {
            highlightNode(defaultNode);
          }
        });
      });
  </script></body>
</html>