<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Political Ontology Viewer</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { padding: 10px; background: #f4f4f4; }
    #cy { width: 100vw; height: 90vh; border-top: 1px solid #ccc; }
    input, button { font-size: 16px; padding: 4px 8px; margin-right: 5px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="text" id="nodeSearch" placeholder="Enter node ID">
    <button onclick="focusOnNode(document.getElementById('nodeSearch').value)">Focus</button>
    <button onclick="resetView()">Reset View</button>
  </div>
  <div id="cy"></div>

  <script>
    fetch('graph.json')
      .then(res => res.json())
      .then(graphData => {
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [...graphData.nodes, ...graphData.edges],
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'background-color': ele => {
                  const type = ele.data('type');
                  const colors = {
                    Individual: '#1f77b4',
                    Campaign: '#d62728',
                    Group: '#9467bd',
                    Institution: '#2ca02c',
                    Policy: '#ff7f0e',
                    Event: '#8c564b',
                    Media: '#17becf',
                    Place: '#7f7f7f'
                  };
                  return colors[type] || '#ccc';
                },
                'text-valign': 'center',
                'text-halign': 'center',
                'color': '#fff',
                'text-outline-width': 1,
                'text-outline-color': '#000',
                'width': 40,
                'height': 40
              }
            },
            {
              selector: 'edge',
              style: {
                'label': 'data(label)',
                'curve-style': 'bezier',
                'target-arrow-shape': 'triangle',
                'line-color': '#aaa',
                'target-arrow-color': '#aaa',
                'font-size': 10,
                'text-rotation': 'autorotate',
                'text-margin-y': -8
              }
            },
            {
              selector: '.faded',
              style: {
                'opacity': 0.1,
                'text-opacity': 0.05
              }
            }
          ],
          layout: {
            name: 'cose',
            animate: true,
            fit: true,
            padding: 100,
            nodeRepulsion: 100000,
            idealEdgeLength: 150
          }
        });

        // Focus on node when clicked
        cy.on('tap', 'node', function(evt) {
          const node = evt.target;
          highlightNode(node);
        });

        window.focusOnNode = function(id) {
          const node = cy.getElementById(id);
          if (node && node.length > 0) {
            highlightNode(node);
          } else {
            alert('Node not found');
          }
        }

        window.resetView = function() {
          cy.elements().removeClass('faded');
          cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
        }

        function highlightNode(node) {
  cy.elements().removeClass('faded');
  cy.elements().addClass('faded');

  const center = { x: 0, y: 0 };
  node.position(center);
  node.removeClass('faded');

  const neighbors = node.connectedNodes();
  neighbors.removeClass('faded');
  node.connectedEdges().removeClass('faded');

  const others = cy.nodes().not(neighbors).not(node);
  others.removeClass('faded');

  const radius1 = 200;
  const radius2 = 400;

  // First ring: direct neighbors
  const angleStep1 = (2 * Math.PI) / neighbors.length;
  neighbors.forEach((ele, i) => {
    const angle = i * angleStep1;
    ele.position({
      x: center.x + radius1 * Math.cos(angle),
      y: center.y + radius1 * Math.sin(angle)
    });
  });

  // Second ring: everything else
  const angleStep2 = (2 * Math.PI) / others.length;
  others.forEach((ele, i) => {
    const angle = i * angleStep2;
    ele.position({
      x: center.x + radius2 * Math.cos(angle),
      y: center.y + radius2 * Math.sin(angle)
    });
  });

  cy.layout({ name: 'preset' }).run();
  cy.animate({ fit: { eles: cy.elements(), padding: 100 }, duration: 500 });
}, zoom: 2, duration: 500 });
        }

        // Auto-focus on default node
        cy.ready(() => {
          const defaultNode = cy.getElementById('individual_0');
          if (defaultNode && defaultNode.length > 0) {
            highlightNode(defaultNode);
          }
        });
      });
  </script>
</body>
</html>
